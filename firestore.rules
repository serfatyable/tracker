rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // ===========================
    // HELPER FUNCTIONS: Auth & Role
    // ===========================

    function isSignedIn() {
      return request.auth != null;
    }

    function userDocPath() {
      return "/databases/" + database + "/documents/users/" + request.auth.uid;
    }

    function hasUserDoc() {
      return exists(path(userDocPath()));
    }

    function getUserRole() {
      return hasUserDoc() ? get(path(userDocPath())).data.role : null;
    }

    function isTutorOrAdmin() {
      return isSignedIn() && (getUserRole() == 'tutor' || getUserRole() == 'admin');
    }

    function isTutor() {
      return isSignedIn() && getUserRole() == 'tutor';
    }

    function isAdmin() {
      return isSignedIn() && getUserRole() == 'admin';
    }

    // Approval gating: only approved users get elevated role permissions
    function getUserStatus() {
      return hasUserDoc() ? get(path(userDocPath())).data.status : null;
    }

    function isApproved() {
      // Treat 'active' as approved; backward-compatible with potential 'approved'
      return isSignedIn() && (getUserStatus() in ['active', 'approved']);
    }

    function isAdminApproved() {
      return isApproved() && getUserRole() == 'admin';
    }

    function isTutorApproved() {
      return isApproved() && getUserRole() == 'tutor';
    }

    function isTutorOrAdminApproved() {
      return isTutorApproved() || isAdminApproved();
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isOwnerOfRotation(rotationId) {
      return isSignedIn() && exists(/databases/$(database)/documents/rotations/$(rotationId)) && (request.auth.uid in get(/databases/$(database)/documents/rotations/$(rotationId)).data.ownerTutorIds);
    }

    // Check if tutor is assigned to a resident (for tasks)
    // NOTE: This relies on tutorIds being stored on the task document itself
    // If tutorIds is not present, falls back to rotation ownership check
    function isTutorForTask(taskData) {
      // If task has tutorIds array (from assignment), check if tutor is in it
      return (taskData.keys().hasAll(['tutorIds']) && request.auth.uid in taskData.tutorIds) ||
             // Fallback: check if tutor owns the rotation
             isOwnerOfRotation(taskData.rotationId);
    }

    // ===========================
    // HELPER FUNCTIONS: Validation
    // ===========================

    // String validation
    function isValidString(value, minLength, maxLength) {
      return value is string && value.size() >= minLength && value.size() <= maxLength;
    }

    // Email validation (basic)
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }

    // Date validation (ISO format YYYY-MM-DD)
    function isValidISODate(dateStr) {
      return dateStr is string && dateStr.matches('[0-9]{4}-[0-9]{2}-[0-9]{2}');
    }

    // Timestamp validation
    function isValidTimestamp(value) {
      return value is timestamp;
    }

    // Number validation
    function isValidNumber(value, min, max) {
      return value is number && value >= min && value <= max;
    }

    // Array validation
    function isValidArray(value, maxSize) {
      return value is list && value.size() <= maxSize;
    }

    // Check if rotation exists
    function rotationExists(rotationId) {
      return exists(/databases/$(database)/documents/rotations/$(rotationId));
    }

    // Check if user exists
    function userExists(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    // Rate limiting: Check if enough time has passed since last document (basic throttle)
    // Prevents rapid-fire document creation by checking createdAt timestamp
    function hasThrottlePassed(minSecondsBetween) {
      // Allow if no createdAt (first document) or enough time has passed
      return !('createdAt' in resource.data) ||
             (request.time > resource.data.createdAt + duration.value(minSecondsBetween, 's'));
    }

    // Field immutability: Check that immutable fields haven't changed
    function immutableFieldsUnchanged(immutableFields) {
      return immutableFields.toSet().difference(
        resource.data.diff(request.resource.data).unchangedKeys()
      ).size() == 0;
    }

    // ===========================
    // HELPER FUNCTIONS: Schema Validation
    // ===========================

    // Validate user document schema
    function isValidUserSchema(data) {
      let baseValid = data.keys().hasAll(['role', 'status', 'settings']) &&
                     (data.role in ['resident', 'tutor', 'admin']) &&
                     (data.status in ['pending', 'active', 'disabled']) &&
                     data.settings is map &&
                     data.settings.language in ['en', 'he'];

      // Resident-specific validation
      let residentValid = data.role != 'resident' || (
        data.keys().hasAll(['residencyStartDate']) &&
        isValidISODate(data.residencyStartDate)
      );

      return baseValid && residentValid;
    }

    // Validate task document schema
    function isValidTaskSchema(data) {
      return data.keys().hasAll(['userId', 'rotationId', 'itemId', 'status']) &&
             isValidString(data.userId, 1, 128) &&
             isValidString(data.rotationId, 1, 128) &&
             isValidString(data.itemId, 1, 128) &&
             (data.status in ['pending', 'approved', 'rejected']) &&
             (!('count' in data) || (data.count is number && data.count >= 0 && data.count <= 10000)) &&
             (!('requiredCount' in data) || (data.requiredCount is number && data.requiredCount >= 0 && data.requiredCount <= 10000)) &&
             (!('tutorIds' in data) || isValidArray(data.tutorIds, 50));
    }

    // Validate rotation document schema
    function isValidRotationSchema(data) {
      return data.keys().hasAll(['name', 'createdAt']) &&
             isValidString(data.name, 1, 200) &&
             isValidTimestamp(data.createdAt) &&
             (!('status' in data) || (data.status in ['active', 'inactive', 'finished'])) &&
             (!('ownerTutorIds' in data) || isValidArray(data.ownerTutorIds, 100));
    }

    // Validate assignment document schema
    function isValidAssignmentSchema(data) {
      return data.keys().hasAll(['residentId', 'rotationId', 'tutorIds', 'status']) &&
             isValidString(data.residentId, 1, 128) &&
             isValidString(data.rotationId, 1, 128) &&
             isValidArray(data.tutorIds, 50) &&
             (data.status in ['inactive', 'active', 'finished']);
    }

    // Validate reflection document schema
    function isValidReflectionSchema(data) {
      return data.keys().hasAll(['taskOccurrenceId', 'taskType', 'templateKey', 'templateVersion', 'authorId', 'authorRole', 'residentId', 'answers']) &&
             isValidString(data.taskOccurrenceId, 1, 256) &&
             isValidString(data.taskType, 1, 100) &&
             isValidString(data.templateKey, 1, 100) &&
             isValidNumber(data.templateVersion, 1, 1000) &&
             isValidString(data.authorId, 1, 128) &&
             (data.authorRole in ['resident', 'tutor']) &&
             isValidString(data.residentId, 1, 128) &&
             data.answers is map;
    }

    // Validate rotation petition schema
    function isValidRotationPetitionSchema(data) {
      return data.keys().hasAll(['residentId', 'rotationId', 'type', 'status', 'requestedAt']) &&
             isValidString(data.residentId, 1, 128) &&
             isValidString(data.rotationId, 1, 128) &&
             (data.type in ['activate', 'finish']) &&
             (data.status in ['pending', 'approved', 'denied']) &&
             isValidTimestamp(data.requestedAt);
    }

    // Validate exam document schema
    function isValidExamSchema(data) {
      return data.keys().hasAll(['examDate', 'subjects', 'createdAt', 'createdBy', 'updatedAt', 'updatedBy', 'isActive']) &&
             isValidTimestamp(data.examDate) &&
             data.subjects is list &&
             data.subjects.size() <= 10 &&
             isValidTimestamp(data.createdAt) &&
             isValidTimestamp(data.updatedAt) &&
             isValidString(data.createdBy, 1, 128) &&
             isValidString(data.updatedBy, 1, 128) &&
             data.isActive is bool;
    }

    // ===========================
    // COLLECTION RULES
    // ===========================

    // Users: can create, read, and update their own profile document at users/{uid}; approved tutors/admins can read/update any
    match /users/{uid} {
      allow create: if isOwner(uid) &&
                       isValidUserSchema(request.resource.data) &&
                       request.resource.data.keys().hasAll(['role', 'status', 'settings']);

      allow read: if isOwner(uid) || isTutorOrAdminApproved();

      allow update: if (isOwner(uid) || isTutorOrAdminApproved()) &&
                       isValidUserSchema(request.resource.data) &&
                       // Immutable fields: role cannot change after creation (status can change via admin)
                       request.resource.data.role == resource.data.role;

      allow delete: if isAdminApproved(); // Only admins can delete users
    }

    // Tasks: owners can read/create/update their own tasks; approved tutors/admins have restricted access
    match /tasks/{taskId} {
      // AUTHORIZATION: Tutors can only read tasks for residents they supervise
      // - Admins can read all tasks
      // - Residents can only read their own tasks
      // - Tutors can read tasks if:
      //   a) They are listed in the task's tutorIds array (copied from assignment), OR
      //   b) They own the rotation (as a fallback)
      allow read: if isAdminApproved() ||
        (isSignedIn() && resource.data.userId == request.auth.uid) ||
        (isTutorApproved() && isTutorForTask(resource.data));

      allow create: if isSignedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       isValidTaskSchema(request.resource.data) &&
                       // Cross-collection validation: rotation must exist
                       rotationExists(request.resource.data.rotationId) &&
                       // Validate user is the creator
                       userExists(request.resource.data.userId);

      // Tutors can update tasks only for rotations they own; approved admins can update any; owners (residents) can update their own
      allow update: if (isAdminApproved() ||
                       (isTutorApproved() && isOwnerOfRotation(resource.data.rotationId)) ||
                       (isSignedIn() && resource.data.userId == request.auth.uid)) &&
                       isValidTaskSchema(request.resource.data) &&
                       // Immutable fields: userId, rotationId, itemId cannot change after creation
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.rotationId == resource.data.rotationId &&
                       request.resource.data.itemId == resource.data.itemId &&
                       // createdAt cannot change if it exists
                       (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt);

      allow delete: if isAdminApproved() || (isSignedIn() && resource.data.userId == request.auth.uid);
    }

    // Cases: residents can manage their own cases; approved tutors/admins retain full access
    match /cases/{caseId} {
      allow read: if isAdminApproved() || (isSignedIn() && resource.data.userId == request.auth.uid);

      allow create: if isSignedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId']) &&
                       isValidString(request.resource.data.userId, 1, 128);

      allow update: if (isAdminApproved() || (isSignedIn() && resource.data.userId == request.auth.uid)) &&
                       // Immutable: userId cannot change
                       request.resource.data.userId == resource.data.userId &&
                       (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt);

      allow delete: if isAdminApproved() || (isSignedIn() && resource.data.userId == request.auth.uid);
    }

    // Rotations: approved admin-only write; read allowed to anyone (including unauthenticated users during signup)
    match /rotations/{rotationId} {
      allow read: if true; // Public read access needed for signup form

      allow create: if isAdminApproved() &&
                       isValidRotationSchema(request.resource.data);

      allow update: if isAdminApproved() &&
                       isValidRotationSchema(request.resource.data) &&
                       // Immutable: createdAt cannot change
                       request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if isAdminApproved();
    }

    // Rotation nodes: approved admin-only write; read allowed to signed-in users
    match /rotationNodes/{nodeId} {
      allow read: if isSignedIn();

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['rotationId', 'type', 'name', 'order']) &&
                       isValidString(request.resource.data.rotationId, 1, 128) &&
                       isValidString(request.resource.data.name, 1, 200) &&
                       (request.resource.data.type in ['category', 'subject', 'topic', 'subTopic', 'subSubTopic', 'leaf']) &&
                       // Cross-collection validation: rotation must exist
                       rotationExists(request.resource.data.rotationId);

      allow update: if isAdminApproved() &&
                       // Immutable: rotationId cannot change
                       request.resource.data.rotationId == resource.data.rotationId;

      allow delete: if isAdminApproved();
    }

    // Rotation petitions
    match /rotationPetitions/{petitionId} {
      // Residents must be able to read their own petition so the "Start Rotation" flow
      // can verify whether there is already a pending request.
      allow read: if isAdminApproved() || isTutorApproved() ||
        (isSignedIn() && resource.data.residentId == request.auth.uid);

      allow create: if isSignedIn() &&
                       request.resource.data.residentId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       isValidRotationPetitionSchema(request.resource.data) &&
                       // Cross-collection validation: rotation and resident must exist
                       rotationExists(request.resource.data.rotationId) &&
                       userExists(request.resource.data.residentId);

      // Approved tutors may resolve petitions for rotations they own; must be a status transition from pending -> approved/denied
      allow update: if (isAdminApproved() ||
                       (isTutorApproved() && isOwnerOfRotation(resource.data.rotationId) &&
                        resource.data.status == 'pending' &&
                        (request.resource.data.status in ['approved', 'denied']))) &&
                       isValidRotationPetitionSchema(request.resource.data) &&
                       // Immutable fields: residentId, rotationId, type, requestedAt cannot change
                       request.resource.data.residentId == resource.data.residentId &&
                       request.resource.data.rotationId == resource.data.rotationId &&
                       request.resource.data.type == resource.data.type &&
                       request.resource.data.requestedAt == resource.data.requestedAt;

      allow delete: if false;
    }

    // Assignments: approved admin can access all; residents can read their own assignment; tutors can read assignments for rotations they own
    match /assignments/{assignmentId} {
      allow read: if isAdminApproved() || (isSignedIn() && resource.data.residentId == request.auth.uid) || isTutorApproved();

      allow create: if isAdminApproved() &&
                       isValidAssignmentSchema(request.resource.data) &&
                       // Cross-collection validation: rotation and resident must exist
                       rotationExists(request.resource.data.rotationId) &&
                       userExists(request.resource.data.residentId);

      // Approved admin retains full control; approved tutors can only add/remove themselves from tutorIds for owned rotation and active assignment
      allow update: if isValidAssignmentSchema(request.resource.data) &&
                       // Immutable fields: residentId, rotationId cannot change
                       request.resource.data.residentId == resource.data.residentId &&
                       request.resource.data.rotationId == resource.data.rotationId &&
                       (isAdminApproved() || (
                        isTutorApproved() &&
                        resource.data.status == 'active' &&
                        isOwnerOfRotation(resource.data.rotationId) &&
                        // Only tutorIds may change; all other fields unchanged (including status)
                        request.resource.data.startedAt == resource.data.startedAt &&
                        request.resource.data.endedAt == resource.data.endedAt &&
                        request.resource.data.status == resource.data.status &&
                        (
                          // Add self (size +1, previously not present)
                          (!(request.auth.uid in resource.data.tutorIds) && (request.auth.uid in request.resource.data.tutorIds) && (request.resource.data.tutorIds.size() == resource.data.tutorIds.size() + 1)) ||
                          // Remove self (size -1, previously present)
                          ((request.auth.uid in resource.data.tutorIds) && !(request.auth.uid in request.resource.data.tutorIds) && (request.resource.data.tutorIds.size() == resource.data.tutorIds.size() - 1))
                        )
                      ));

      allow delete: if isAdminApproved();
    }

    // Announcements
    match /announcements/{id} {
      allow read: if isSignedIn();

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['title', 'createdAt']) &&
                       isValidString(request.resource.data.title, 1, 500) &&
                       isValidTimestamp(request.resource.data.createdAt);

      allow update: if isAdminApproved() &&
                       // Immutable: createdAt cannot change
                       (!('createdAt' in resource.data) || request.resource.data.createdAt == resource.data.createdAt);

      allow delete: if isAdminApproved();
    }

    // Morning meetings
    match /morningMeetings/{docId} {
      allow read: if isSignedIn();

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['date', 'dateKey', 'dayOfWeek', 'title']) &&
                       isValidTimestamp(request.resource.data.date) &&
                       isValidISODate(request.resource.data.dateKey) &&
                       isValidString(request.resource.data.title, 1, 500);

      allow update: if isAdminApproved() &&
                       // Immutable: date, dateKey cannot change
                       request.resource.data.date == resource.data.date &&
                       request.resource.data.dateKey == resource.data.dateKey;

      allow delete: if isAdminApproved();
    }

    // On-call: assignments, per-day snapshots, shifts, and aliases
    match /onCallAssignments/{id} {
      allow read: if isSignedIn();

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['dateKey', 'stationKey', 'userId', 'startAt', 'endAt']) &&
                       isValidISODate(request.resource.data.dateKey) &&
                       isValidString(request.resource.data.userId, 1, 128) &&
                       isValidTimestamp(request.resource.data.startAt) &&
                       isValidTimestamp(request.resource.data.endAt) &&
                       request.resource.data.endAt > request.resource.data.startAt;

      allow update: if isAdminApproved() &&
                       // Immutable: userId, dateKey cannot change
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.dateKey == resource.data.dateKey;

      allow delete: if isAdminApproved();
    }

    match /onCallDays/{dateKey} {
      allow read: if isSignedIn();

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['dateKey', 'date', 'stations']) &&
                       isValidISODate(request.resource.data.dateKey) &&
                       isValidTimestamp(request.resource.data.date) &&
                       request.resource.data.stations is map;

      allow update: if isAdminApproved() &&
                       // Immutable: dateKey, date cannot change
                       request.resource.data.dateKey == resource.data.dateKey &&
                       request.resource.data.date == resource.data.date;

      allow delete: if isAdminApproved();
    }

    match /onCallShifts/{id} {
      allow read: if isSignedIn();
      allow create, update, delete: if isAdminApproved();
    }

    match /onCallAliases/{aliasKey} {
      allow read: if isAdminApproved();
      allow create, update, delete: if isAdminApproved();
    }

    // Reflection templates (versioned)
    match /reflectionTemplates/{templateId} {
      allow read: if isSignedIn(); // UI will filter to status == 'published'

      allow create: if isAdminApproved() &&
                       request.resource.data.keys().hasAll(['templateKey', 'version', 'status', 'audience', 'taskTypes', 'sections']) &&
                       isValidString(request.resource.data.templateKey, 1, 100) &&
                       isValidNumber(request.resource.data.version, 1, 1000) &&
                       (request.resource.data.status in ['draft', 'published']) &&
                       (request.resource.data.audience in ['resident', 'tutor']) &&
                       isValidArray(request.resource.data.taskTypes, 100) &&
                       isValidArray(request.resource.data.sections, 50);

      allow update: if isAdminApproved();
      allow delete: if isAdminApproved();
    }

    // Reflections (immutable after submit; approved admin may add adminComment)
    match /reflections/{rid} {
      allow read: if isAdminApproved() || (isSignedIn() && (resource.data.residentId == request.auth.uid || resource.data.tutorId == request.auth.uid));

      allow create: if isSignedIn() &&
                       request.resource.data.authorId == request.auth.uid &&
                       isValidReflectionSchema(request.resource.data) &&
                       // Cross-collection validation: resident must exist
                       userExists(request.resource.data.residentId);

      allow update: if isAdminApproved() &&
                       isValidReflectionSchema(request.resource.data) &&
                       request.resource.data.keys().hasOnly(['taskOccurrenceId','taskType','templateKey','templateVersion','authorId','authorRole','residentId','tutorId','answers','submittedAt','adminComment']) &&
                       // All fields except adminComment are immutable after submission
                       !(resource.data.submittedAt != null && (
                         request.resource.data.taskOccurrenceId != resource.data.taskOccurrenceId ||
                         request.resource.data.answers != resource.data.answers ||
                         request.resource.data.authorId != resource.data.authorId ||
                         request.resource.data.authorRole != resource.data.authorRole ||
                         request.resource.data.residentId != resource.data.residentId ||
                         request.resource.data.tutorId != resource.data.tutorId ||
                         request.resource.data.templateKey != resource.data.templateKey ||
                         request.resource.data.templateVersion != resource.data.templateVersion ||
                         request.resource.data.submittedAt != resource.data.submittedAt
                       ));

      allow delete: if false;
    }

    // Exams: all authenticated users can read; approved tutors/admins can manage
    match /exams/{examId} {
      allow read: if isSignedIn();

      allow create: if isTutorOrAdminApproved() &&
                       isValidExamSchema(request.resource.data);

      allow update: if isTutorOrAdminApproved() &&
                       isValidExamSchema(request.resource.data) &&
                       // Immutable: createdAt, createdBy cannot change
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.createdBy == resource.data.createdBy;

      allow delete: if isTutorOrAdminApproved();
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}